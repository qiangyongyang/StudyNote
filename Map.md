# HashMap:

**一.hashmap的主要参数都有哪些？**

​	1.容量capadcity：数组长度：；默认值为16

​	2.极限容量，表示hashmap能承受的最大桶容量为2的30次方，超过这个容量将不再扩容。碰撞

​	3.负载因子（loadfactor，默认0.75）

​	4.阈值，算法为capacity*loadfactory，大致当map中entry数量大于此阈值时进行扩容（1.8）

**二.hashmap的数据结构是什么样子的？**

​	*1.数组+链表（java7）：*

​		每个链表的结点是嵌套类 Entry 的实例，Entry 包含四个属性：key, value, hash 值和用于链表的next.

​		``````static class Entry<K,V> implements Map.Entry<K,V> {``````     

​			`````` final K key; ``````   

​			`````` V value;    ``````              

​			``````Entry<K,V> next;    ``````    

​			``` int hash; }```

​	*2.数组+链表+红黑树（java8）：*    

​	         根据 Java7 HashMap 的介绍，我们知道，查找的时候，根据 hash 值我们能够快速定位到数组的具体下 

​        标，但是之后的话，需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决于链表的长度。                    

​               为了降低这部分的开销，在 Java8 中，当链表中的元素超过了 8 个以后，会将链表转换为红黑树，在这些         

​	位置进行查找的时候可以降低时间复杂度为 O(logN)。   

**三.hash算法：**

​	*1.计算key的哈希值：*

​		key的hashcode值先右移16位，再与hashcode值进行异或操作，即不求进位只求按位相加的值

​	*2.计算在数组中的位置：*

​		用数组长度的值-1，与上面算出的值，进行与运算。

​       $\color{red}{通过扰动函数最终的目的是让散列分布地更加均匀。}$

**四.存取过程：**

​	*1.存过程：（java7）*：

​		1.1 判断如果为空table，先对table进行构造:

​			在第一个元素插入 HashMap 的时候做一次数组的初始化，就是先确定初始的数组大小**(2的n次**

​			**方)**，并计算数组扩容的阈值。

​		1.2 判断key是否为null：

​			1.2.1为null也可以存，null的key一定放在table的0号位置
        	1.3 算出key的hash值：   int hash = hash(key)
                       根据hash值算出在table中的位置

​                1.4 放入K\V，遍历链表,如果位置上存在相同key，进行替换value为新的，且将替换的旧的value返回，

​			若不存在，则插在链表首部。**（java8是插入尾部）**

​		1.5 增加一个entry，有两种情况：1、如果此位置存在entry，将此位置变为插入的entry，且将插入

​	              entry的next节点变为原来的entry**（存在相同key）**；2、如果此位置不存在entry则直接插入新的                                   		  

​		      entry 。**（不存在相同key）**  

​    *2.取过程：（java7):*

​		1.1 判断key是否为null：

​			1.2.1key为null，在table的0号位置取
        	1.2 算出key的hash值：   int hash = hash(key)
                       根据hash值算出在table中的位置

​		1.3 遍历链表，寻找key相等的那个Entry

   *3.存过程：（java8）*：

​		插入时需要判断结点是链表节点还是红黑树结点？链表则插入尾部：红黑树的插入方法

​		插入完成后需要判断链表中的个数是否大于8？继续：转化成红黑树

*4.取过程：（java8)  :*

​                4.1计算 key 的 hash 值，根据 hash 值找到对应数组下标: hash & (length-1)

​		4.2判断数组该位置处的元素是否刚好就是我们要找的，如果不是，走第三步

​		4.3判断该元素类型是否是 TreeNode，如果是，用红黑树的方法取数据，如果不是，走第四步

​		4.4遍历链表，直到找到相等(==或equals)的 key







​		

 



​		



​		

​	









